{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Munity documentation This document has been generated to this repository : https://github.com/munityapps/munity-doc Feel free to report Issues or send your Pullrequests to improve it. Or just report any problem to our discord : https://discord.gg/6zmcnvnh Thank you a lot ! What is Munity Munity is a fullstack framework to build your SaaS really fast! It handles all configurations to start your SaaS A Progressive Web App with ReactJS, Redux, i18n, Prime React, Websocket... build with Typescript! An API build with django rest framework, already setup with many plugins (JWT, Timeseries DB, Mailing, Scheduler...) A docker configuration to start on local or deploy on your server, we can also handle hosting for you Our goals : Accelerate all web project creation Help teams to build togethere and following same best practices Learn from community to improve community experience Munity main concepts There is two place to be in Munity Overmind Workspaces At connection we check if an user has access to overmind or wanted workspace. Overmind The overmind can be access from the root route of your platform : http://localhost/ The overmind is a place where you can access all your platform information, you will find : - A dashboard with metrics to have an overview on what's append - A list of workspaces (see below) - All your platform users seprated in \"Workspace users\" and \"Superusers\". Workspaces You client informations are separated in different workspaces. User can have access to one or many users Workspace has it's own model registered in its area / database but some models are cross workspaces : - User list are located in overmind - Roles and rights are common for all workspaces Model available out of the box Munity framework came with the following models. Workspaces : module munityapps/workspace , the needed tooling to work with workspaces User : module munityapps/user GenericGroup : module munityapps/genericgroups , all models can be groupable. There are the basic mechanisme to assemble things togethere. Role : It is used in Munity to give access to a given resource to a user Permission : Role has permissions on resources. Permissions can be : list, retreive, update, create or delete. They exists for each resources. With each of them list, form and a complete live cycle is already available. Munity MOJOs \"The code you write makes you a programmer. The code you delete makes you a good one. The code you don't have to write makes you a great one.\" - Mario Fusco \"Keep it simple stupid\" \"Simplicity is the ultimate sophistication\" - Leonardo da Vinci technical stack We use docker to work in local environment We use kubernetes to deploy in production Munity has 5 main services : Web proxy Frontend Backend Timeseries/Relationnal database Websocket Web proxy We choose Traefik as a proxy because it is really simple to use and powerful. There is no configuration files needed only params in docker-compose.yml. Frontend We choose React with Timescript to build Munity frontend. We really like the component approch of React and the community built around. To manage application state we choose Redux , easy to understand, visualize and debug. We choose Prime React to have a strong libraries of basic component and we like the theme approch to customise it. We add a translation system based on i18 We choose socket.io to manage websockets To test application we use : Unit tests : Jest End to end tests : Cypress Score : Web vital Backend For backend we use Django rest framework for it simplicity and the very large range of features that the community provide. Backend use JWT approch to manage user sessions. To make functional test we use Newman from Postman to test all endpoints. Timeseries and relational database PostgresSQL has many interesting features, for exemple NoSQL embed in SQL Relationnal is a smart approch. Since we work with Data, a timeseries database is a mandatory for performance and scalability, so we use the Timescale surcharge. Websocket To update client from server we add a websocket server. It is a simply NodeJS server with socket.io connected to redis Pubsub to forward event to clients over channal.","title":"What is Munity"},{"location":"#welcome-to-munity-documentation","text":"This document has been generated to this repository : https://github.com/munityapps/munity-doc Feel free to report Issues or send your Pullrequests to improve it. Or just report any problem to our discord : https://discord.gg/6zmcnvnh Thank you a lot !","title":"Welcome to Munity documentation"},{"location":"#what-is-munity","text":"Munity is a fullstack framework to build your SaaS really fast! It handles all configurations to start your SaaS A Progressive Web App with ReactJS, Redux, i18n, Prime React, Websocket... build with Typescript! An API build with django rest framework, already setup with many plugins (JWT, Timeseries DB, Mailing, Scheduler...) A docker configuration to start on local or deploy on your server, we can also handle hosting for you Our goals : Accelerate all web project creation Help teams to build togethere and following same best practices Learn from community to improve community experience","title":"What is Munity"},{"location":"#munity-main-concepts","text":"There is two place to be in Munity Overmind Workspaces At connection we check if an user has access to overmind or wanted workspace.","title":"Munity main concepts"},{"location":"#overmind","text":"The overmind can be access from the root route of your platform : http://localhost/ The overmind is a place where you can access all your platform information, you will find : - A dashboard with metrics to have an overview on what's append - A list of workspaces (see below) - All your platform users seprated in \"Workspace users\" and \"Superusers\".","title":"Overmind"},{"location":"#workspaces","text":"You client informations are separated in different workspaces. User can have access to one or many users Workspace has it's own model registered in its area / database but some models are cross workspaces : - User list are located in overmind - Roles and rights are common for all workspaces","title":"Workspaces"},{"location":"#model-available-out-of-the-box","text":"Munity framework came with the following models. Workspaces : module munityapps/workspace , the needed tooling to work with workspaces User : module munityapps/user GenericGroup : module munityapps/genericgroups , all models can be groupable. There are the basic mechanisme to assemble things togethere. Role : It is used in Munity to give access to a given resource to a user Permission : Role has permissions on resources. Permissions can be : list, retreive, update, create or delete. They exists for each resources. With each of them list, form and a complete live cycle is already available.","title":"Model available out of the box"},{"location":"#munity-mojos","text":"\"The code you write makes you a programmer. The code you delete makes you a good one. The code you don't have to write makes you a great one.\" - Mario Fusco \"Keep it simple stupid\" \"Simplicity is the ultimate sophistication\" - Leonardo da Vinci","title":"Munity MOJOs"},{"location":"#technical-stack","text":"We use docker to work in local environment We use kubernetes to deploy in production Munity has 5 main services : Web proxy Frontend Backend Timeseries/Relationnal database Websocket","title":"technical stack"},{"location":"#web-proxy","text":"We choose Traefik as a proxy because it is really simple to use and powerful. There is no configuration files needed only params in docker-compose.yml.","title":"Web proxy"},{"location":"#frontend","text":"We choose React with Timescript to build Munity frontend. We really like the component approch of React and the community built around. To manage application state we choose Redux , easy to understand, visualize and debug. We choose Prime React to have a strong libraries of basic component and we like the theme approch to customise it. We add a translation system based on i18 We choose socket.io to manage websockets To test application we use : Unit tests : Jest End to end tests : Cypress Score : Web vital","title":"Frontend"},{"location":"#backend","text":"For backend we use Django rest framework for it simplicity and the very large range of features that the community provide. Backend use JWT approch to manage user sessions. To make functional test we use Newman from Postman to test all endpoints.","title":"Backend"},{"location":"#timeseries-and-relational-database","text":"PostgresSQL has many interesting features, for exemple NoSQL embed in SQL Relationnal is a smart approch. Since we work with Data, a timeseries database is a mandatory for performance and scalability, so we use the Timescale surcharge.","title":"Timeseries and relational database"},{"location":"#websocket","text":"To update client from server we add a websocket server. It is a simply NodeJS server with socket.io connected to redis Pubsub to forward event to clients over channal.","title":"Websocket"},{"location":"gethelp/","text":"Get help You can contact us on our discord : Go to Munity discord Report an issue on Github Ask help from community","title":"Get help"},{"location":"gethelp/#get-help","text":"You can contact us on our discord :","title":"Get help"},{"location":"gethelp/#go-to-munity-discord","text":"","title":"Go to Munity discord"},{"location":"gethelp/#report-an-issue-on-github","text":"","title":"Report an issue on Github"},{"location":"gethelp/#ask-help-from-community","text":"","title":"Ask help from community"},{"location":"howtostart/","text":"How to use How to use Munity Munity is an open source fullstack framework so you can read all the source code here : https://github.com/munityapps/munity To use Munity you need a boilerplate A boilerplate is an already ready to use application that is plugged to Munity through packages. Blank boilerplate : https://github.com/munityapps/blank_boilerplate Backoffice, Dataviz and other boilerplate will come soon Get started Start Munity, the easy way git clone https://github.com/munityapps/blank_boilerplate cd blank_boilerplate cp ./env.sample ./.env ./scripts/start.sh You can access munity on http://localhost:3000 Start Munity step by step Get munity boilerplate git clone https://github.com/munityapps/blank_boilerplate cd blank_boilerplate Start Munity services docker-compose up -d Create your database and migrate docker-compose exec db psql -U munityapps -c \"create database munity\" docker-compose exec api python manage.py migrate Database is now available, restart API docker-compose restart api Create your first user docker-compose exec api python manage.py createsuperuser Start frontend cd app ; yarn install ; yarn start","title":"How to start"},{"location":"howtostart/#how-to-use","text":"","title":"How to use"},{"location":"howtostart/#how-to-use-munity","text":"Munity is an open source fullstack framework so you can read all the source code here : https://github.com/munityapps/munity To use Munity you need a boilerplate A boilerplate is an already ready to use application that is plugged to Munity through packages. Blank boilerplate : https://github.com/munityapps/blank_boilerplate Backoffice, Dataviz and other boilerplate will come soon","title":"How to use Munity"},{"location":"howtostart/#get-started","text":"","title":"Get started"},{"location":"howtostart/#start-munity-the-easy-way","text":"git clone https://github.com/munityapps/blank_boilerplate cd blank_boilerplate cp ./env.sample ./.env ./scripts/start.sh You can access munity on http://localhost:3000","title":"Start Munity, the easy way"},{"location":"howtostart/#start-munity-step-by-step","text":"Get munity boilerplate git clone https://github.com/munityapps/blank_boilerplate cd blank_boilerplate Start Munity services docker-compose up -d Create your database and migrate docker-compose exec db psql -U munityapps -c \"create database munity\" docker-compose exec api python manage.py migrate Database is now available, restart API docker-compose restart api Create your first user docker-compose exec api python manage.py createsuperuser Start frontend cd app ; yarn install ; yarn start","title":"Start Munity step by step"},{"location":"importantfile/","text":"Important boilerplate files All important files : \ud83d\udce6blank_boilerplate \u2523 \ud83d\udcc2api \u2503 \u2523 \ud83d\udcc2project \u2503 \u2503 \u2523 \ud83d\udcdcsettings.py //-> your backend apps and middleware here \u2503 \u2503 \u2523 \ud83d\udcdcurls.py //-> your backend new routes here \u2503 \u2517 \ud83d\udcdcrequirements.txt //-> your backend libs here \u2523 \ud83d\udcc2app \u2503 \u2523 \ud83d\udcc2public \u2503 \u2503 \u2523 \ud83d\udcdc[...] //-> custom icons / app name / embbed js libs \u2503 \u2523 \ud83d\udcc2src \u2503 \u2503 \u2523 \ud83d\udcdci18n.ts //-> your translations \u2503 \u2503 \u2523 \ud83d\udcdcindex.tsx //-> call frontend Munity framework \u2503 \u2503 \u2523 \ud83d\udcdcstore.ts //-> your frontend store \u2503 \u2503 \u2517 \ud83d\udcdcstyles.scss //-> your frontend style \u2503 \u2523 \ud83d\udcdcpackage.json //-> your frontend libraries \u2523 \ud83d\udcdc.env //-> your platform settings \u2523 \ud83d\udcdcdocker-compose.yml //-> your services Frontend, the src/index.ts file The is the root of your frontend application. Munity is invoked here. First Munity Proverds, then Munity main component. This main component take many params to tweak default behavior : <MunityApp // Cosmetic components logoLogin={logo} loadingWorkspace={LoadingMunity} // Functionnal components overmindSidebar={<MunityOvermindSidebar />} workspaceNavbar={<Navbar leftPart={NavbarLeft} centerPart={NavbarCenter} rightPart={NavbarRight} />} overmindNavbar={<OvermindNavbar leftPart={OvermindNavbarLeft} centerPart={OvermindNavbarCenter} rightPart={OvermindNavbarRight} />} // Routes newOvermindRoutes={[ // <Route key={'overmind_youpibanana'} path=\"/youpibanana\" component={() => <>Overmind Youpi Banana \\o/</>} /> ]} newWorkspaceRoutes={[ // <Route key={'workspace_youpibanana'} path=\"/workspace/:workspace_slug/youpibanana\" component={() => <>Workspace Youpi Banana \\o/</>} /> ]} > {/* Custom routes outsite of overmind or workspace, usefull for fullscreen pages*/} {/* <Route path=\"/maps/:location/only_active\" component={((location: string) => MapFullscreen({ location }))} /> */} </MunityApp> Backend, the projet/settings.py file This is main configuraiton file for your application. Munity is already bootstrapped inside and you can extend as a standard Django Rest Framework application behavior. This file is pretty big so we only show interesting parts : # [...] # Application definition INSTALLED_APPS = [ # Munity is load here \"munity\", \"munity.generic_groups\", \"munity.users\", \"munity.workspaces\", \"munity.authorization\", \"munity.records\", \"munity.settings\", # App # Add your applications here (ex: \"myapp\" will refear ./api/myapp directory) # See this documentation to create your apps : https://docs.djangoproject.com/en/3.2/intro/tutorial01/#creating-the-polls-app ] # [...] MIDDLEWARE = [ # [...] # Add your middleware here ] # [...] # If you extend user model you can change the default model user here AUTH_USER_MODEL = \"users.User\" Add new route Improve navbars Change layout Change current theme How to extend currend user How to create group categories","title":"Important files"},{"location":"importantfile/#important-boilerplate-files","text":"","title":"Important boilerplate files"},{"location":"importantfile/#all-important-files","text":"\ud83d\udce6blank_boilerplate \u2523 \ud83d\udcc2api \u2503 \u2523 \ud83d\udcc2project \u2503 \u2503 \u2523 \ud83d\udcdcsettings.py //-> your backend apps and middleware here \u2503 \u2503 \u2523 \ud83d\udcdcurls.py //-> your backend new routes here \u2503 \u2517 \ud83d\udcdcrequirements.txt //-> your backend libs here \u2523 \ud83d\udcc2app \u2503 \u2523 \ud83d\udcc2public \u2503 \u2503 \u2523 \ud83d\udcdc[...] //-> custom icons / app name / embbed js libs \u2503 \u2523 \ud83d\udcc2src \u2503 \u2503 \u2523 \ud83d\udcdci18n.ts //-> your translations \u2503 \u2503 \u2523 \ud83d\udcdcindex.tsx //-> call frontend Munity framework \u2503 \u2503 \u2523 \ud83d\udcdcstore.ts //-> your frontend store \u2503 \u2503 \u2517 \ud83d\udcdcstyles.scss //-> your frontend style \u2503 \u2523 \ud83d\udcdcpackage.json //-> your frontend libraries \u2523 \ud83d\udcdc.env //-> your platform settings \u2523 \ud83d\udcdcdocker-compose.yml //-> your services","title":"All important files :"},{"location":"importantfile/#frontend-the-srcindexts-file","text":"The is the root of your frontend application. Munity is invoked here. First Munity Proverds, then Munity main component. This main component take many params to tweak default behavior : <MunityApp // Cosmetic components logoLogin={logo} loadingWorkspace={LoadingMunity} // Functionnal components overmindSidebar={<MunityOvermindSidebar />} workspaceNavbar={<Navbar leftPart={NavbarLeft} centerPart={NavbarCenter} rightPart={NavbarRight} />} overmindNavbar={<OvermindNavbar leftPart={OvermindNavbarLeft} centerPart={OvermindNavbarCenter} rightPart={OvermindNavbarRight} />} // Routes newOvermindRoutes={[ // <Route key={'overmind_youpibanana'} path=\"/youpibanana\" component={() => <>Overmind Youpi Banana \\o/</>} /> ]} newWorkspaceRoutes={[ // <Route key={'workspace_youpibanana'} path=\"/workspace/:workspace_slug/youpibanana\" component={() => <>Workspace Youpi Banana \\o/</>} /> ]} > {/* Custom routes outsite of overmind or workspace, usefull for fullscreen pages*/} {/* <Route path=\"/maps/:location/only_active\" component={((location: string) => MapFullscreen({ location }))} /> */} </MunityApp>","title":"Frontend, the src/index.ts file"},{"location":"importantfile/#backend-the-projetsettingspy-file","text":"This is main configuraiton file for your application. Munity is already bootstrapped inside and you can extend as a standard Django Rest Framework application behavior. This file is pretty big so we only show interesting parts : # [...] # Application definition INSTALLED_APPS = [ # Munity is load here \"munity\", \"munity.generic_groups\", \"munity.users\", \"munity.workspaces\", \"munity.authorization\", \"munity.records\", \"munity.settings\", # App # Add your applications here (ex: \"myapp\" will refear ./api/myapp directory) # See this documentation to create your apps : https://docs.djangoproject.com/en/3.2/intro/tutorial01/#creating-the-polls-app ] # [...] MIDDLEWARE = [ # [...] # Add your middleware here ] # [...] # If you extend user model you can change the default model user here AUTH_USER_MODEL = \"users.User\"","title":"Backend, the projet/settings.py file"},{"location":"importantfile/#add-new-route","text":"","title":"Add new route"},{"location":"importantfile/#improve-navbars","text":"","title":"Improve navbars"},{"location":"importantfile/#change-layout","text":"","title":"Change layout"},{"location":"importantfile/#change-current-theme","text":"","title":"Change current theme"},{"location":"importantfile/#how-to-extend-currend-user","text":"","title":"How to extend currend user"},{"location":"importantfile/#how-to-create-group-categories","text":"","title":"How to create group categories"},{"location":"managecustomcontent/","text":"How to add a new content ! Out of the box, boilerplate is a fully functionnable application but you want to add your custom data inside it. We will take as an exemple a new Ticket model and implement it on frontend and backend. Exemple with tickets: Backend part First you need to create your new app that will be your Ticket app system. $ docker-compose exec api python manage.py startapp tickets That will create the following files : \ud83d\udce6api/tickets \u2523 \ud83d\udcc2migrations //-> dicrectory for your migration file, django take care of that <3 \u2523 \ud83d\udcdcadmin.py //-> use for django admin \u2523 \ud83d\udcdcapps.py //-> basic config file for this app \u2523 \ud83d\udcdcmodels.py //-> new model used by your app \u2523 \ud83d\udcdctests.py //-> used for unitary test \u2517 \ud83d\udcdcviews.py //-> your viewset / serializer of your app will be here You only want to adapt your model models.py and your view/serializer views.py . In munity data are splitted around workspaces and can also be groupable. Munity take care of that. To manage Tickets in our application we can modify our models to match following : models.py from django.db import models from munity.models import MunityModel, MunityGroupableModel from munity.users.models import User from django.db.models.deletion import SET_NULL # Below we say two things : # - Ticket are a Munity model, that's mean it is related to workspaces, it is timesteamped, and has an UUIDv4 for id. # - Ticket are a Munity groupable model, that's mean they can be grouped class Ticket(MunityModel), MunityGroupableModel: class TicketStatus(models.TextChoices): TODO = 'TODO', 'TODO' DOING = 'DOING', 'DOING' DONE = 'DONE', 'DONE' class TicketSeverity(models.TextChoices): HIGH = 'H', 'Hight' MEDIUM = 'M', 'Medium' LOW = 'L', 'Low' class TicketPriority(models.TextChoices): IMPORTANT = \"red\", 'Important' NORMAL = \"orange\", 'Normal' TRIVIAL = \"green\", 'Trivial' name = models.CharField(max_length=256, blank=False, null=False) description = models.TextField(blank=True, null=True) # Use a foreign key ot refer user assign_to = models.ForeignKey(User, related_name='assign_to_users', on_delete=SET_NULL, blank=True, null=True) status = models.CharField( choices=TicketStatus.choices, default=TicketStatus.TODO, ) severity = models.CharField( choices=TicketSeverity.choices, default=TicketSeverity.TODO, ) priority = models.CharField( choices=TicketPriority.choices, default=TicketPriority.TODO, ) serializer_class = LaboratorySerializer Then adapt your views.py : from rest_framework import serializers from .models import Ticket from munity.views import MunityWorkspaceViewSet class TicketSerializer(serializers.ModelSerializer): class Meta: fields = '__all__' model=Ticket # expend user to get all user information on tickets assign_to = UserSerializer() class TicketViewSet(MunityWorkspaceViewSet): serializer_class = TicketSerializer Create database table Thanks to Django this part is crazy easy : $ docker-compose exec api python manage.py makemigration tickets $ docker-compose exec api python manage.py migrate Manage right for new model By default your users cannot access your new model, you have to add permissions. Munity provide a CLI to care of that for you. It will give read only access to user and full access to Admin and Owner. This command will create Permissions : - list ticket - update ticket - create ticket - delete ticket - retreive ticket And give access to list and retrieve to User role and all Permissions to Admin / Owner $ docker-compose exec api python manage.py initiate_default_authorization Permissions works as following : This exemple show how John access workspace foo as an User so it can list users . Frontend part On previous part we create and give access to following endpoints : GET https://api.*DOMAIN_NAME*/tickets/ to get all tickets POST https://api.*DOMAIN_NAME*/tickets/ to create new ticket PATCH https://api.*DOMAIN_NAME*/tickets/*uuid*/ to update specific ticket DELETE https://api.*DOMAIN_NAME*/tickets/*uuid*/ to delete specific ticket Munity frontend app provide a tool to link directly these enpoint to a store. Create a new slice, for exemple in app/tickets/slice.tsx . Add following code inside: import { sliceFactory } from 'munityapps/factory/slice'; export enum TicketStatus{ TODO = \"TODO\", DOING = \"DOING\", DONE = \"DONE\" } export enum TicketSeverity { HIGH = \"H\", MEDIUM = \"M\", LOW = \"M\" } export enum TicketPriority { IMPORTANT = \"red\", NORMAL = \"Normal\", TRIVIAL = \"Trivial\" } export interface Ticket{ id: string, name: number, description: string, status: TicketStatus, severity: TicketSeverity, priority: TicketPriority, created: Date, updated: Date, } export const ticketAPISlice = sliceFactory<Ticket>({ reducerName: 'ticketAPI', endpoint: '/tickets/', name: 'Ticket' }); export const { useGetTicketsQuery, useGetTicketQuery, useDeleteTicketMutation, useUpdateTicketMutation, useCreateTicketMutation, } = ticketAPISlice 3. Add your slice to your store in app/store.ts import { configureStore } from '@reduxjs/toolkit' import { munityMiddleware, munityReducer } from 'munityapps/store'; import { ticketAPISlice } from './tickets/slice'; // [...] // munityReducer[storeKey] = reducer; munityReducer[ticketAPISlice.reducerPath] = ticketAPISlice.reducer; // [...] // munityMiddleware.push(middleware); munityMiddleware.push(ticketAPISlice.middleware); // [...] const store = configureStore({ reducer: munityReducer, middleware: getDefaultMiddleware => getDefaultMiddleware() .concat(munityMiddleware) }) export default store; 4. Now you can use your new component anyware in your application : ```typescript import { TicketForm } from \"./form\"; import { TicketList } from \"./list\"; import { Ticket, useDeleteTicketMutation, useGetTicketsQuery } from \"./slice\"; import './style.scss'; const NotesList = (props: {notes: Array }) => { const [deleteNote, { isLoading: isDeleting, isError: deleteError, isSuccess: deleteSuccess }] = useDeleteNoteMutation(); return <div className={'notes-list-wrapper'}> <h1 className='title'>Notes</h1> <div className={'notes-list'}> {props.notes?.map((note: Note) => { return <div key={note.id} className='note-item'> <div className='note-title title'>{note.name}</div> <div style={{position: 'absolute', right: '8px', top: '4px', display: 'flex'}}> { note.generic_groups.map((group) => { return <Tags groupId={group} /> })} </div> <div className='note-description description'>{note.description}</div> <UserAvatar userId={note.created_by} /> <div className='relative-open-form-btn action-buttons'> <OpenFormButton edition header={'Editer une note'} form={<NoteForm note={note} closeModal={() => null} step={null}/>} /> <DeleteButton deleteFunction={() => deleteNote(note.id)}/> </div> </div> })} </div> </div> } export default NotesList;","title":"Manage custom content"},{"location":"managecustomcontent/#how-to-add-a-new-content","text":"Out of the box, boilerplate is a fully functionnable application but you want to add your custom data inside it. We will take as an exemple a new Ticket model and implement it on frontend and backend. Exemple with tickets:","title":"How to add a new content !"},{"location":"managecustomcontent/#backend-part","text":"First you need to create your new app that will be your Ticket app system. $ docker-compose exec api python manage.py startapp tickets That will create the following files : \ud83d\udce6api/tickets \u2523 \ud83d\udcc2migrations //-> dicrectory for your migration file, django take care of that <3 \u2523 \ud83d\udcdcadmin.py //-> use for django admin \u2523 \ud83d\udcdcapps.py //-> basic config file for this app \u2523 \ud83d\udcdcmodels.py //-> new model used by your app \u2523 \ud83d\udcdctests.py //-> used for unitary test \u2517 \ud83d\udcdcviews.py //-> your viewset / serializer of your app will be here You only want to adapt your model models.py and your view/serializer views.py . In munity data are splitted around workspaces and can also be groupable. Munity take care of that. To manage Tickets in our application we can modify our models to match following : models.py from django.db import models from munity.models import MunityModel, MunityGroupableModel from munity.users.models import User from django.db.models.deletion import SET_NULL # Below we say two things : # - Ticket are a Munity model, that's mean it is related to workspaces, it is timesteamped, and has an UUIDv4 for id. # - Ticket are a Munity groupable model, that's mean they can be grouped class Ticket(MunityModel), MunityGroupableModel: class TicketStatus(models.TextChoices): TODO = 'TODO', 'TODO' DOING = 'DOING', 'DOING' DONE = 'DONE', 'DONE' class TicketSeverity(models.TextChoices): HIGH = 'H', 'Hight' MEDIUM = 'M', 'Medium' LOW = 'L', 'Low' class TicketPriority(models.TextChoices): IMPORTANT = \"red\", 'Important' NORMAL = \"orange\", 'Normal' TRIVIAL = \"green\", 'Trivial' name = models.CharField(max_length=256, blank=False, null=False) description = models.TextField(blank=True, null=True) # Use a foreign key ot refer user assign_to = models.ForeignKey(User, related_name='assign_to_users', on_delete=SET_NULL, blank=True, null=True) status = models.CharField( choices=TicketStatus.choices, default=TicketStatus.TODO, ) severity = models.CharField( choices=TicketSeverity.choices, default=TicketSeverity.TODO, ) priority = models.CharField( choices=TicketPriority.choices, default=TicketPriority.TODO, ) serializer_class = LaboratorySerializer Then adapt your views.py : from rest_framework import serializers from .models import Ticket from munity.views import MunityWorkspaceViewSet class TicketSerializer(serializers.ModelSerializer): class Meta: fields = '__all__' model=Ticket # expend user to get all user information on tickets assign_to = UserSerializer() class TicketViewSet(MunityWorkspaceViewSet): serializer_class = TicketSerializer","title":"Backend part"},{"location":"managecustomcontent/#create-database-table","text":"Thanks to Django this part is crazy easy : $ docker-compose exec api python manage.py makemigration tickets $ docker-compose exec api python manage.py migrate","title":"Create database table"},{"location":"managecustomcontent/#manage-right-for-new-model","text":"By default your users cannot access your new model, you have to add permissions. Munity provide a CLI to care of that for you. It will give read only access to user and full access to Admin and Owner. This command will create Permissions : - list ticket - update ticket - create ticket - delete ticket - retreive ticket And give access to list and retrieve to User role and all Permissions to Admin / Owner $ docker-compose exec api python manage.py initiate_default_authorization Permissions works as following : This exemple show how John access workspace foo as an User so it can list users .","title":"Manage right for new model"},{"location":"managecustomcontent/#frontend-part","text":"On previous part we create and give access to following endpoints : GET https://api.*DOMAIN_NAME*/tickets/ to get all tickets POST https://api.*DOMAIN_NAME*/tickets/ to create new ticket PATCH https://api.*DOMAIN_NAME*/tickets/*uuid*/ to update specific ticket DELETE https://api.*DOMAIN_NAME*/tickets/*uuid*/ to delete specific ticket Munity frontend app provide a tool to link directly these enpoint to a store. Create a new slice, for exemple in app/tickets/slice.tsx . Add following code inside: import { sliceFactory } from 'munityapps/factory/slice'; export enum TicketStatus{ TODO = \"TODO\", DOING = \"DOING\", DONE = \"DONE\" } export enum TicketSeverity { HIGH = \"H\", MEDIUM = \"M\", LOW = \"M\" } export enum TicketPriority { IMPORTANT = \"red\", NORMAL = \"Normal\", TRIVIAL = \"Trivial\" } export interface Ticket{ id: string, name: number, description: string, status: TicketStatus, severity: TicketSeverity, priority: TicketPriority, created: Date, updated: Date, } export const ticketAPISlice = sliceFactory<Ticket>({ reducerName: 'ticketAPI', endpoint: '/tickets/', name: 'Ticket' }); export const { useGetTicketsQuery, useGetTicketQuery, useDeleteTicketMutation, useUpdateTicketMutation, useCreateTicketMutation, } = ticketAPISlice 3. Add your slice to your store in app/store.ts import { configureStore } from '@reduxjs/toolkit' import { munityMiddleware, munityReducer } from 'munityapps/store'; import { ticketAPISlice } from './tickets/slice'; // [...] // munityReducer[storeKey] = reducer; munityReducer[ticketAPISlice.reducerPath] = ticketAPISlice.reducer; // [...] // munityMiddleware.push(middleware); munityMiddleware.push(ticketAPISlice.middleware); // [...] const store = configureStore({ reducer: munityReducer, middleware: getDefaultMiddleware => getDefaultMiddleware() .concat(munityMiddleware) }) export default store; 4. Now you can use your new component anyware in your application : ```typescript import { TicketForm } from \"./form\"; import { TicketList } from \"./list\"; import { Ticket, useDeleteTicketMutation, useGetTicketsQuery } from \"./slice\"; import './style.scss'; const NotesList = (props: {notes: Array }) => { const [deleteNote, { isLoading: isDeleting, isError: deleteError, isSuccess: deleteSuccess }] = useDeleteNoteMutation(); return <div className={'notes-list-wrapper'}> <h1 className='title'>Notes</h1> <div className={'notes-list'}> {props.notes?.map((note: Note) => { return <div key={note.id} className='note-item'> <div className='note-title title'>{note.name}</div> <div style={{position: 'absolute', right: '8px', top: '4px', display: 'flex'}}> { note.generic_groups.map((group) => { return <Tags groupId={group} /> })} </div> <div className='note-description description'>{note.description}</div> <UserAvatar userId={note.created_by} /> <div className='relative-open-form-btn action-buttons'> <OpenFormButton edition header={'Editer une note'} form={<NoteForm note={note} closeModal={() => null} step={null}/>} /> <DeleteButton deleteFunction={() => deleteNote(note.id)}/> </div> </div> })} </div> </div> } export default NotesList;","title":"Frontend part"}]}