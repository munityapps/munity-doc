{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Munity documentation What is Munity Munity is a platform to build your SaaS faster! Munity can handle many busness case Munity respects best design pattern and is based on famous open source software. Munity is higly customizable Our goal : Accelerate all project based on data Focused on community, open source first Be the best modular platform on internet Architecture We use docker to work in local environment We use kubernetes to deploy in production Munity has 8 services : Web proxy Frontend Backend Timeseries/Relationnal database Data warehouse Scheduler (worker and beat) Pubsub and volatile database Websocket Web proxy We choose Traefik as a proxy because it is really simple to use and powerful. Moreover, traefik works well with kubernetes. The configuration through label (for docker) and charts (for kubernetes) remove the needs to build a configuration file. It is very convenient. Frontend We choose React with Timescript to build Munity frontend. We really like the component approch of React and the community built around. To manage application state we choose Redux , easy to understand, visualize and debug. We choose Prime React to have a strong libraries of basic component and we like the theme approch to customise it. We add a translation system based on i18 We choose socket.io to manage websockets To test application we use : Unit tests : Jest End to end tests : Cypress Score : Web vital Backend For backend we use Django rest framework for it simplicity and the very large range of features that the community provide. Backend use JWT approch to manage user sessions. To make functional test we use Newman from Postman to test all endpoints. Timeseries and relational database PostgresSQL has many interesting features, for exemple NoSQL embed in SQL Relationnal is a smart approch. Since we work with Data, a timeseries database is a mandatory for performance and scalability, so we use the Timescale surcharge. Data warehouse Data can be collected and stored directly in previous backend service. But we think it's a better approch to isolated data collected in a dedicated service. To do so, we use FastAPI because it is very fast and simple to use. It is writted in Python as all backend services. Scheduler Again, we search a python service to run the scheduler. Django recommand to use Celery so we implement it with redis as Pubsub event and result storage. We use django celery beat to store scheduled task directly on database. Pubsub and volatile database As said before, we choose Redis to sync Munity services togethere with observer pattern. It is also used to cache and to store volatile data. Websocket To update client from server we add a websocket server. It is a simply NodeJS server with socket.io connected to redis Pubsub to forward event to clients over channal.","title":"What is Munity"},{"location":"#welcome-to-munity-documentation","text":"","title":"Welcome to Munity documentation"},{"location":"#what-is-munity","text":"Munity is a platform to build your SaaS faster! Munity can handle many busness case Munity respects best design pattern and is based on famous open source software. Munity is higly customizable Our goal : Accelerate all project based on data Focused on community, open source first Be the best modular platform on internet","title":"What is Munity"},{"location":"#architecture","text":"We use docker to work in local environment We use kubernetes to deploy in production Munity has 8 services : Web proxy Frontend Backend Timeseries/Relationnal database Data warehouse Scheduler (worker and beat) Pubsub and volatile database Websocket","title":"Architecture"},{"location":"#web-proxy","text":"We choose Traefik as a proxy because it is really simple to use and powerful. Moreover, traefik works well with kubernetes. The configuration through label (for docker) and charts (for kubernetes) remove the needs to build a configuration file. It is very convenient.","title":"Web proxy"},{"location":"#frontend","text":"We choose React with Timescript to build Munity frontend. We really like the component approch of React and the community built around. To manage application state we choose Redux , easy to understand, visualize and debug. We choose Prime React to have a strong libraries of basic component and we like the theme approch to customise it. We add a translation system based on i18 We choose socket.io to manage websockets To test application we use : Unit tests : Jest End to end tests : Cypress Score : Web vital","title":"Frontend"},{"location":"#backend","text":"For backend we use Django rest framework for it simplicity and the very large range of features that the community provide. Backend use JWT approch to manage user sessions. To make functional test we use Newman from Postman to test all endpoints.","title":"Backend"},{"location":"#timeseries-and-relational-database","text":"PostgresSQL has many interesting features, for exemple NoSQL embed in SQL Relationnal is a smart approch. Since we work with Data, a timeseries database is a mandatory for performance and scalability, so we use the Timescale surcharge.","title":"Timeseries and relational database"},{"location":"#data-warehouse","text":"Data can be collected and stored directly in previous backend service. But we think it's a better approch to isolated data collected in a dedicated service. To do so, we use FastAPI because it is very fast and simple to use. It is writted in Python as all backend services.","title":"Data warehouse"},{"location":"#scheduler","text":"Again, we search a python service to run the scheduler. Django recommand to use Celery so we implement it with redis as Pubsub event and result storage. We use django celery beat to store scheduled task directly on database.","title":"Scheduler"},{"location":"#pubsub-and-volatile-database","text":"As said before, we choose Redis to sync Munity services togethere with observer pattern. It is also used to cache and to store volatile data.","title":"Pubsub and volatile database"},{"location":"#websocket","text":"To update client from server we add a websocket server. It is a simply NodeJS server with socket.io connected to redis Pubsub to forward event to clients over channal.","title":"Websocket"},{"location":"howtostart/","text":"How to start Get the code git clone git@github.com:munityapps/munity.git cd munity Prepare environment In .env file set correct variables depending on your projet : # URLS HOMEPAGE_URL=localhost APP_SUFFIX_URL=localhost API_SUFFIX_URL=api.localhost # API API_DEBUG=True GUNICORN_WORKER_NUMBER=5 API_LOG_LEVEL=debug DB_HOST=db DB_PORT=5432 DEFAULT_DB_NAME=munity # DB POSTGRES_PORT=5432 POSTGRES_USER=admin POSTGRES_PASSWORD=**************** PGDATA=/var/lib/postgresql/data Start Munity First your need to run the initialization script ./scripts/initialisation.sh It will : Create munity and scheduler databases Migrate database to last version Prepare and start all service on current environement Once initialization has been done one time, you just have to start project with : docker-compose up -d For developer environment Bind local sources to docker Code is copied in docker images at build, so if you change the code it will not update living code without rebuild your dockers. To have a better developper experience you can simply create a copy from your local code to docker code directly. To do so you have to create a new project file (that is git ignored) named docker-compose.override.yaml with following content : version: '3.7' services: api: volumes: - ./api:/usr/src/app celery_worker: volumes: - ./api:/usr/src/app celery_beat: volumes: - ./api:/usr/src/app app: volumes: - ./app:/var/www Use yarn start from docker Futhermore, if you want to start React project in \"server mode\" to activate hot reload and other dev tools you can bind serve port in same file : version: '3.7' services: app: ports : - 3000:3000 This will permit to start app project with docker-compose exec app yarn start and go to http://localhost:3000 for developement purpose. Important : Since Munity detect backend url from frontend URL. You probabily have to adapt the backend URL in localstorage. Key is munity_api_url . Access database from the outside By using the same approch you can bind Timescale database (postgresql in fact) to outside : version: '3.7' services: db: ports : - 65432:5432 You can connect to your database with client that you want on URL : localhost:65432 . All in one If you want all these modification you just have to create docker-compose.override.yaml file with following content : version: '3.7' services: api: volumes: - ./api:/usr/src/app celery_worker: volumes: - ./api:/usr/src/app celery_beat: volumes: - ./api:/usr/src/app app: volumes: - ./app:/var/www ports : - 3000:3000 db: ports : - 65432:5432","title":"How to start"},{"location":"howtostart/#how-to-start","text":"","title":"How to start"},{"location":"howtostart/#get-the-code","text":"git clone git@github.com:munityapps/munity.git cd munity","title":"Get the code"},{"location":"howtostart/#prepare-environment","text":"In .env file set correct variables depending on your projet : # URLS HOMEPAGE_URL=localhost APP_SUFFIX_URL=localhost API_SUFFIX_URL=api.localhost # API API_DEBUG=True GUNICORN_WORKER_NUMBER=5 API_LOG_LEVEL=debug DB_HOST=db DB_PORT=5432 DEFAULT_DB_NAME=munity # DB POSTGRES_PORT=5432 POSTGRES_USER=admin POSTGRES_PASSWORD=**************** PGDATA=/var/lib/postgresql/data","title":"Prepare environment"},{"location":"howtostart/#start-munity","text":"First your need to run the initialization script ./scripts/initialisation.sh It will : Create munity and scheduler databases Migrate database to last version Prepare and start all service on current environement Once initialization has been done one time, you just have to start project with : docker-compose up -d","title":"Start Munity"},{"location":"howtostart/#for-developer-environment","text":"","title":"For developer environment"},{"location":"howtostart/#bind-local-sources-to-docker","text":"Code is copied in docker images at build, so if you change the code it will not update living code without rebuild your dockers. To have a better developper experience you can simply create a copy from your local code to docker code directly. To do so you have to create a new project file (that is git ignored) named docker-compose.override.yaml with following content : version: '3.7' services: api: volumes: - ./api:/usr/src/app celery_worker: volumes: - ./api:/usr/src/app celery_beat: volumes: - ./api:/usr/src/app app: volumes: - ./app:/var/www","title":"Bind local sources to docker"},{"location":"howtostart/#use-yarn-start-from-docker","text":"Futhermore, if you want to start React project in \"server mode\" to activate hot reload and other dev tools you can bind serve port in same file : version: '3.7' services: app: ports : - 3000:3000 This will permit to start app project with docker-compose exec app yarn start and go to http://localhost:3000 for developement purpose. Important : Since Munity detect backend url from frontend URL. You probabily have to adapt the backend URL in localstorage. Key is munity_api_url .","title":"Use yarn start from docker"},{"location":"howtostart/#access-database-from-the-outside","text":"By using the same approch you can bind Timescale database (postgresql in fact) to outside : version: '3.7' services: db: ports : - 65432:5432 You can connect to your database with client that you want on URL : localhost:65432 .","title":"Access database from the outside"},{"location":"howtostart/#all-in-one","text":"If you want all these modification you just have to create docker-compose.override.yaml file with following content : version: '3.7' services: api: volumes: - ./api:/usr/src/app celery_worker: volumes: - ./api:/usr/src/app celery_beat: volumes: - ./api:/usr/src/app app: volumes: - ./app:/var/www ports : - 3000:3000 db: ports : - 65432:5432","title":"All in one"}]}